<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Stick vs Rocks â€” Fixed Physics</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <style>
    :root { color-scheme: dark; }
    html, body {
      margin: 0;
      height: 100%;
      overflow: hidden;
      background: #0f0f10;
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Inter, Arial, sans-serif;
    }
    #score {
      position: fixed;
      top: 12px;
      left: 12px;
      padding: 6px 10px;
      background: rgba(0,0,0,0.35);
      border: 1px solid rgba(255,255,255,0.08);
      border-radius: 10px;
      font-weight: 700;
      letter-spacing: 0.5px;
      user-select: none;
      z-index: 10;
    }
    #tips {
      position: fixed;
      bottom: 10px;
      left: 12px;
      padding: 6px 10px;
      font-size: 12px;
      color: #bdbdbd;
      background: rgba(0,0,0,0.25);
      border: 1px solid rgba(255,255,255,0.06);
      border-radius: 10px;
      user-select: none;
      z-index: 10;
    }
    canvas { display: block; }
  </style>
</head>
<body>
  <div id="score">Score: 0</div>
  <div id="tips">Move the mouse to swing. Bat tracks your motion with a smooth PD controller.</div>
  <canvas id="gameCanvas"></canvas>

  <script>
    // =============================================================
    // Stick vs Rocks â€” Physics Fixes
    // -------------------------------------------------------------
    // ðŸ”§ What changed vs your version:
    // 1) Replaced the torque-from-lateral-speed hack with a stable
    //    PD controller that steers the bat toward the mouse motion
    //    direction (perpendicular to motion, like a real bat swing).
    // 2) Added sub-stepping for physics to avoid tunneling & jitter
    //    when frame time spikes.
    // 3) Tweaked restitution/damping and clamped angular velocity.
    // 4) Cleaned collision response & kept a light reaction torque.
    // Result: snappy, predictable control and solid hits.
    // =============================================================

    // ========= Canvas =========
    const canvas = document.getElementById("gameCanvas");
    const ctx = canvas.getContext("2d");
    function resize() { canvas.width = innerWidth; canvas.height = innerHeight; }
    addEventListener("resize", resize); resize();

    // ========= Score =========
    let score = 0;
    const scoreDisplay = document.getElementById("score");

    // ========= Tunables =========
    const MAX_ROCKS = 40;                 // rock cap
    const SPAWN_INTERVAL_MS = 450;

    // Physics scaling (pixels â†” meters)
    const PPM = 100;                       // 100 px â‰ˆ 1 m
    const GRAVITY = 9.81;                  // m/s^2 (realistic g)
    const g_px = GRAVITY * PPM;            // px/s^2

    // Bat params (mass/inertia in SI based on length in meters)
    const BAT_MASS = 0.9;                  // kg
    const MAX_ANG_VEL = 18;                // rad/s clamp (keeps swings sane)

    // PD control (torque = Kp * angleError - Kd * angVel)
    // These are physical torques (NÂ·m). Keep moderate.
    const Kp = 85;                         // proportional gain
    const Kd = 18;                         // damping on angular velocity

    // Rock physics
    const ROCK_MASS = 0.25;                // kg (arbitrary-ish)
    const ROCK_E = 0.75;                   // restitution with bat
    const WALL_E = 0.9;                    // side/top bounciness
    const REACTION_FACTOR = 0.2;           // reaction coupling to bat

    // ========= Audio (subtle "boooo") =========
    let audioCtx = null;
    function initAudio() { if (!audioCtx) audioCtx = new (window.AudioContext || window.webkitAudioContext)(); }
    document.addEventListener("pointerdown", () => { initAudio(); audioCtx.resume && audioCtx.resume(); }, { once: true });
    function playBoo(intensity = 1) {
      if (!audioCtx) return;
      const now = audioCtx.currentTime;
      const dur = 0.22 + 0.12 * Math.min(intensity, 2);
      const osc = audioCtx.createOscillator();
      const filt = audioCtx.createBiquadFilter();
      const gain = audioCtx.createGain();
      osc.type = "sine";
      filt.type = "lowpass";
      filt.frequency.value = 700;
      filt.Q.value = 0.5;
      osc.frequency.setValueAtTime(180, now);
      osc.frequency.exponentialRampToValueAtTime(90, now + dur);
      gain.gain.setValueAtTime(0.0001, now);
      gain.gain.exponentialRampToValueAtTime(0.45 * Math.min(1, intensity), now + 0.01);
      gain.gain.exponentialRampToValueAtTime(0.0001, now + dur);
      osc.connect(filt).connect(gain).connect(audioCtx.destination);
      osc.start(now); osc.stop(now + dur + 0.05);
    }

    // ========= Bat (pivot at mouse) =========
    const stick = {
      x: canvas.width / 2,
      y: canvas.height / 2,
      lengthPx: 170,
      thickness: 22,
      angle: 0,
      angVel: 0,
      targetAngle: 0,
      lastTargetAngle: 0,
      get length_m() { return this.lengthPx / PPM; },
      get I() { return (1/3) * BAT_MASS * this.length_m * this.length_m; } // rod about one end
    };

    // ========= Rocks =========
    const rocks = [];
    function spawnRock() {
      if (rocks.length >= MAX_ROCKS) return; // CAP
      const speedY = 80 + Math.random() * 160;   // px/s
      const speedX = (Math.random() - 0.5) * 140;
      rocks.push({
        x: Math.random() * canvas.width,
        y: -40,
        radius: 22 + Math.random() * 18,
        vx: speedX,
        vy: speedY,
        rotation: Math.random() * Math.PI * 2,
        rotationSpeed: (Math.random() - 0.5) * 1.6, // rad/s
        shape: generateRockShape(16, 0.45)
      });
    }

    function generateRockShape(sides = 14, roughness = 0.35) {
      const pts = [];
      for (let i = 0; i < sides; i++) {
        const ang = (i / sides) * Math.PI * 2;
        const radJitter = 1 + (Math.random() * 2 - 1) * roughness;
        pts.push({ ang, radJitter });
      }
      return pts;
    }

    // ========= Utils =========
    function wrapAngle(a) {
      // wrap to [-PI, PI)
      a = (a + Math.PI) % (Math.PI * 2);
      return a < 0 ? a + Math.PI * 2 - Math.PI : a - Math.PI;
    }
    function angleDiff(target, a) {
      let d = wrapAngle(target - a);
      return d;
    }
    function mixAngle(a, b, t) {
      // shortest path blend
      const d = angleDiff(b, a);
      return wrapAngle(a + d * t);
    }

    // ========= Collision (circle vs oriented rect) =========
    function circleVsBatWithContact(cx, cy, cr) {
      const rx = cx - stick.x, ry = cy - stick.y;
      const c = Math.cos(stick.angle), s = Math.sin(stick.angle);
      // world -> local (bat along +local Y)
      const lx =  c * rx + s * ry;
      const ly = -s * rx + c * ry;
      const halfW = stick.thickness / 2, minY = 0, maxY = stick.lengthPx;
      const qx = Math.max(-halfW, Math.min(lx, halfW));
      const qy = Math.max(minY,  Math.min(ly, maxY));
      const dx = lx - qx, dy = ly - qy;
      const dist2 = dx*dx + dy*dy;

      let nLocalX, nLocalY, penetration;
      if (dist2 === 0) { // perfectly on the boundary; pick nearest face normal
        const distLeft = (lx + halfW), distRight = (halfW - lx), distBottom = (ly - minY), distTop = (maxY - ly);
        const minDist = Math.min(distLeft, distRight, distBottom, distTop);
        if (minDist === distLeft)       { nLocalX = -1; nLocalY =  0; }
        else if (minDist === distRight) { nLocalX =  1; nLocalY =  0; }
        else if (minDist === distBottom){ nLocalX =  0; nLocalY = -1; }
        else                            { nLocalX =  0; nLocalY =  1; }
        penetration = cr;
      } else {
        const dist = Math.sqrt(dist2);
        nLocalX = dx / dist; nLocalY = dy / dist;
        penetration = cr - dist;
        if (penetration < 0) return null;
      }

      // local -> world
      const nx =  c * nLocalX - s * nLocalY;
      const ny =  s * nLocalX + c * nLocalY;
      const qWorldX = stick.x + (c * qx - s * qy);
      const qWorldY = stick.y + (s * qx + c * qy);

      return { normal: { x: nx, y: ny }, contact: { x: qWorldX, y: qWorldY }, penetration };
    }

    // ========= Drawing =========
    function drawRock(r) {
      ctx.save();
      ctx.translate(r.x, r.y);
      ctx.rotate(r.rotation);
      const R = r.radius;
      ctx.beginPath();
      const p0 = r.shape[0];
      ctx.moveTo(Math.cos(p0.ang) * R * p0.radJitter, Math.sin(p0.ang) * R * p0.radJitter);
      for (let i = 1; i < r.shape.length; i++) {
        const p = r.shape[i];
        ctx.lineTo(Math.cos(p.ang) * R * p.radJitter, Math.sin(p.ang) * R * p.radJitter);
      }
      ctx.closePath();
      const grad = ctx.createRadialGradient(-R * 0.2, -R * 0.25, R * 0.2, 0, 0, R);
      grad.addColorStop(0, "#a1a1a1"); grad.addColorStop(1, "#555");
      ctx.fillStyle = grad;
      ctx.shadowColor = "rgba(0,0,0,0.6)"; ctx.shadowBlur = 8; ctx.fill();
      ctx.shadowBlur = 0; ctx.lineWidth = 2; ctx.strokeStyle = "#2d2d2d"; ctx.stroke();
      ctx.globalAlpha = 0.35;
      ctx.beginPath(); ctx.moveTo(-R * 0.2, -R * 0.1); ctx.lineTo(R * 0.35, R * 0.2);
      ctx.moveTo(-R * 0.3, R * 0.25); ctx.lineTo(R * 0.15, -R * 0.05);
      ctx.strokeStyle = "#2a2a2a"; ctx.lineWidth = 1; ctx.stroke();
      ctx.globalAlpha = 1;
      ctx.restore();
    }

    function drawStick() {
      ctx.save();
      ctx.translate(stick.x, stick.y);
      ctx.rotate(stick.angle);
      const L = stick.lengthPx, T = stick.thickness, r = T/2;
      ctx.beginPath();
      ctx.moveTo(-r, 0); ctx.lineTo(-r, L - r); ctx.arc(0, L - r, r, Math.PI, 0, false); ctx.lineTo(r, 0); ctx.closePath();
      const wood = ctx.createLinearGradient(0, 0, 0, L);
      wood.addColorStop(0, "#3b2f1a"); wood.addColorStop(0.5, "#8c6239"); wood.addColorStop(1, "#3b2f1a");
      ctx.fillStyle = wood; ctx.shadowColor = "rgba(0,0,0,0.55)"; ctx.shadowBlur = 10; ctx.fill(); ctx.shadowBlur = 0;
      ctx.lineWidth = 2; ctx.strokeStyle = "#1c1108"; ctx.stroke();
      // grip
      ctx.save(); ctx.beginPath(); ctx.rect(-r, 0, T, Math.min(22, L * 0.15)); ctx.clip();
      ctx.globalAlpha = 0.35;
      for (let y = 2; y < 22; y += 3) { ctx.beginPath(); ctx.moveTo(-r, y); ctx.lineTo(r, y); ctx.strokeStyle = "#2c1f10"; ctx.lineWidth = 1; ctx.stroke(); }
      ctx.globalAlpha = 1; ctx.restore();
      // grain
      ctx.save(); ctx.clip(); ctx.globalAlpha = 0.2;
      for (let y = 6; y < L; y += 14) { ctx.beginPath(); ctx.moveTo(-r + 4, y); ctx.lineTo(r - 4, y + 8); ctx.strokeStyle = "#2c1f10"; ctx.lineWidth = 1; ctx.stroke(); }
      ctx.globalAlpha = 1; ctx.restore();
      // pivot marker
      ctx.beginPath(); ctx.arc(0, 0, 3, 0, Math.PI * 2); ctx.fillStyle = "#ffd166"; ctx.fill(); ctx.lineWidth = 1; ctx.strokeStyle = "#d69e2e"; ctx.stroke();
      ctx.restore();
    }

    function drawBackground() {
      const g = ctx.createRadialGradient(
        canvas.width/2, canvas.height/2, Math.min(canvas.width, canvas.height)*0.1,
        canvas.width/2, canvas.height/2, Math.max(canvas.width, canvas.height)*0.7
      );
      g.addColorStop(0, "#0f0f10"); g.addColorStop(1, "#0a0a0b");
      ctx.fillStyle = g; ctx.fillRect(0, 0, canvas.width, canvas.height);
    }

    // ========= Mouse state =========
    let lastMouseX = stick.x, lastMouseY = stick.y, lastMouseT = performance.now();
    let haveMotion = false; // helps avoid jitter when the mouse is still

    canvas.addEventListener("pointermove", (e) => {
      const now = performance.now();
      const dt = Math.max(0.001, (now - lastMouseT) / 1000);
      const dx = e.clientX - lastMouseX, dy = e.clientY - lastMouseY;

      // Move pivot to mouse
      stick.x = e.clientX; stick.y = e.clientY;

      // Compute desired orientation: perpendicular to motion (bat axis = +local Y)
      const speed = Math.hypot(dx, dy) / dt; // px/s
      if (speed > 40) { // ignore tiny jitter
        const dir = Math.atan2(dy, dx);
        const desired = dir + Math.PI / 2; // rod points perpendicular to motion
        // Smooth target to avoid twitching (time-constant ~100ms)
        const t = 1 - Math.exp(-dt * 10);
        stick.targetAngle = mixAngle(stick.targetAngle, desired, t);
        haveMotion = true;
      } else if (!haveMotion) {
        // Initialize target once on first move
        stick.targetAngle = stick.angle;
      }

      lastMouseX = e.clientX; lastMouseY = e.clientY; lastMouseT = now;
    });

    // ========= Update (dt-based with substeps) =========
    let lastFrameT = performance.now();

    function integrate(subdt) {
      // --- Bat angular dynamics via PD control ---
      const e = angleDiff(stick.targetAngle, stick.angle);
      const tau_pd = Kp * e - Kd * stick.angVel;  // NÂ·m
      // Î± = Ï„ / I
      stick.angVel += (tau_pd / stick.I) * subdt;
      // Clamp
      if (stick.angVel > MAX_ANG_VEL) stick.angVel = MAX_ANG_VEL;
      if (stick.angVel < -MAX_ANG_VEL) stick.angVel = -MAX_ANG_VEL;
      stick.angle = wrapAngle(stick.angle + stick.angVel * subdt);

      // --- Rocks ---
      for (let i = rocks.length - 1; i >= 0; i--) {
        const r = rocks[i];

        // Gravity acceleration (px/s^2)
        r.vy += g_px * subdt;

        // Integrate position
        r.x += r.vx * subdt;
        r.y += r.vy * subdt;
        r.rotation += r.rotationSpeed * subdt;

        // Wall bounces: left/right/top; bottom = delete
        if (r.x - r.radius < 0) {
          r.x = r.radius; r.vx = Math.abs(r.vx) * WALL_E; r.rotationSpeed *= -1;
        } else if (r.x + r.radius > canvas.width) {
          r.x = canvas.width - r.radius; r.vx = -Math.abs(r.vx) * WALL_E; r.rotationSpeed *= -1;
        }
        if (r.y - r.radius < 0) {
          r.y = r.radius; r.vy = Math.abs(r.vy) * WALL_E; r.rotationSpeed *= -1;
        }

        // Bottom: disappear (no bounce)
        if (r.y + r.radius >= canvas.height) {
          rocks.splice(i, 1);
          continue;
        }

        // Bat collision
        const hit = circleVsBatWithContact(r.x, r.y, r.radius);
        if (hit) {
          // Contact normal & point
          const nx = hit.normal.x, ny = hit.normal.y;
          const cx = hit.contact.x, cy = hit.contact.y;

          // Bat surface velocity at contact: v = Ï‰ Ã— r
          const rx = cx - stick.x, ry = cy - stick.y;
          const vSurfX = -stick.angVel * ry;
          const vSurfY =  stick.angVel * rx;

          // Relative velocity (rock minus bat surface)
          const vRelX = r.vx - vSurfX;
          const vRelY = r.vy - vSurfY;
          const vn = vRelX * nx + vRelY * ny;

          if (vn < 0) {
            score++; scoreDisplay.textContent = `Score: ${score}`;

            // Normal impulse (bat â‰ˆ infinite mass)
            let j = -(1 + ROCK_E) * vn * ROCK_MASS;
            // Safety clamp to avoid numerical explosions on rare edge cases
            const jMax = 2.5 * ROCK_MASS * Math.hypot(vRelX, vRelY);
            if (j > jMax) j = jMax;

            r.vx += (j * nx) / ROCK_MASS;
            r.vy += (j * ny) / ROCK_MASS;

            // Tangential grip/friction to add spin & controllability
            const tx = -ny, ty = nx;
            const vt = vRelX * tx + vRelY * ty;
            const jt = -0.12 * vt * ROCK_MASS; // small
            r.vx += (jt * tx) / ROCK_MASS;
            r.vy += (jt * ty) / ROCK_MASS;

            // Spin kick + separation
            r.rotationSpeed += jt * 0.002;
            r.x += nx * (hit.penetration + 0.6);
            r.y += ny * (hit.penetration + 0.6);

            // Reaction torque on the bat (reduced)
            const torqueImpulse = (rx * ny - ry * nx) * j;
            stick.angVel -= (torqueImpulse / stick.I) * REACTION_FACTOR;

            // Sound
            const impact = Math.abs(vn) + Math.abs(stick.angVel) * Math.hypot(rx, ry) / PPM;
            playBoo(Math.min(1 + impact * 0.05, 2));
          }
        }
      }
    }

    function update() {
      const now = performance.now();
      let dt = Math.min(0.05, (now - lastFrameT) / 1000); // clamp if tab hiccups
      lastFrameT = now;

      // Sub-step for stability (<= 8 ms per step)
      const steps = Math.max(1, Math.min(6, Math.ceil(dt / 0.008)));
      const subdt = dt / steps;
      for (let i = 0; i < steps; i++) integrate(subdt);
    }

    // ========= Render =========
    function draw() {
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      drawBackground();
      drawStick();
      for (const r of rocks) drawRock(r);
    }

    function gameLoop() { update(); draw(); requestAnimationFrame(gameLoop); }

    // ========= Start =========
    setInterval(spawnRock, SPAWN_INTERVAL_MS);
    gameLoop();
  </script>
</body>
</html>
