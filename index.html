<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Stick vs Rocks â€” Physics + Natural Look</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <style>
    :root {
      color-scheme: dark;
    }
    html, body {
      margin: 0;
      height: 100%;
      overflow: hidden;
      background: #0f0f10;
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Inter, Arial, sans-serif;
    }
    #score {
      position: fixed;
      top: 12px;
      left: 12px;
      padding: 6px 10px;
      background: rgba(0,0,0,0.35);
      border: 1px solid rgba(255,255,255,0.08);
      border-radius: 10px;
      font-weight: 700;
      letter-spacing: 0.5px;
      user-select: none;
    }
    canvas { display: block; }
  </style>
</head>
<body>
  <div id="score">Score: 0</div>
  <canvas id="gameCanvas"></canvas>

  <script>
    const canvas = document.getElementById("gameCanvas");
    const ctx = canvas.getContext("2d");
    function resize() {
      canvas.width = window.innerWidth;
      canvas.height = window.innerHeight;
    }
    window.addEventListener("resize", resize);
    resize();

    let score = 0;
    const scoreDisplay = document.getElementById("score");

    // -------- Stick (wooden capsule) --------
    const stick = {
      x: canvas.width / 2,
      y: canvas.height / 2,
      width: 160,
      height: 20,
      angle: 0,
      angularVelocity: 0
    };

    let lastMouseX = stick.x;
    let lastMouseY = stick.y;

    // -------- Rocks --------
    const rocks = [];

    function spawnRock() {
      const r = {
        x: Math.random() * canvas.width,
        y: -40,
        radius: 24 + Math.random() * 18,
        vy: 2.2 + Math.random() * 2.2,
        vx: (Math.random() - 0.5) * 0.8,
        rotation: Math.random() * Math.PI * 2,
        rotationSpeed: (Math.random() - 0.5) * 0.03,
        shape: generateRockShape(16, 0.45) // more sides + roughness
      };
      rocks.push(r);
    }

    function generateRockShape(sides = 14, roughness = 0.35) {
      // Irregular polygon around a circle
      const pts = [];
      for (let i = 0; i < sides; i++) {
        const ang = (i / sides) * Math.PI * 2;
        const radJitter = 1 + (Math.random() * 2 - 1) * roughness;
        pts.push({ ang, radJitter });
      }
      return pts;
    }

    function drawRock(r) {
      ctx.save();
      ctx.translate(r.x, r.y);
      ctx.rotate(r.rotation);

      // Build jagged path
      const R = r.radius;
      ctx.beginPath();
      const p0 = r.shape[0];
      ctx.moveTo(Math.cos(p0.ang) * R * p0.radJitter, Math.sin(p0.ang) * R * p0.radJitter);
      for (let i = 1; i < r.shape.length; i++) {
        const p = r.shape[i];
        ctx.lineTo(Math.cos(p.ang) * R * p.radJitter, Math.sin(p.ang) * R * p.radJitter);
      }
      ctx.closePath();

      // Shading: radial gradient gives volume
      const grad = ctx.createRadialGradient(-R * 0.2, -R * 0.25, R * 0.2, 0, 0, R);
      grad.addColorStop(0, "#a1a1a1");
      grad.addColorStop(1, "#555");
      ctx.fillStyle = grad;

      // Soft shadow-ish
      ctx.shadowColor = "rgba(0,0,0,0.6)";
      ctx.shadowBlur = 8;
      ctx.fill();

      ctx.shadowBlur = 0;
      ctx.lineWidth = 2;
      ctx.strokeStyle = "#2d2d2d";
      ctx.stroke();

      // A couple of subtle crack lines for texture (randomized)
      ctx.globalAlpha = 0.35;
      ctx.beginPath();
      ctx.moveTo(-R * 0.2, -R * 0.1);
      ctx.lineTo(R * 0.35, R * 0.2);
      ctx.moveTo(-R * 0.3, R * 0.25);
      ctx.lineTo(R * 0.15, -R * 0.05);
      ctx.strokeStyle = "#2a2a2a";
      ctx.lineWidth = 1;
      ctx.stroke();
      ctx.globalAlpha = 1;

      ctx.restore();
    }

    // -------- Physics & Update --------
    function update() {
      // Angular motion
      stick.angle += stick.angularVelocity;
      // friction (tweak to taste)
      stick.angularVelocity *= 0.985;

      // Update rocks
      for (let i = rocks.length - 1; i >= 0; i--) {
        const r = rocks[i];
        r.x += r.vx;
        r.y += r.vy;
        r.rotation += r.rotationSpeed;

        // Simple collision approximation: distance-from-center
        const dx = r.x - stick.x;
        const dy = r.y - stick.y;
        const dist = Math.hypot(dx, dy);
        const reach = Math.max(stick.width, stick.height) * 0.55; // a bit tighter than before

        if (dist < r.radius + reach) {
          rocks.splice(i, 1);
          score++;
          scoreDisplay.textContent = `Score: ${score}`;
        } else if (r.y - r.radius > canvas.height + 50) {
          rocks.splice(i, 1);
        }
      }
    }

    // -------- Rendering --------
    function drawStick() {
      ctx.save();
      ctx.translate(stick.x, stick.y);
      ctx.rotate(stick.angle);

      const w = stick.width;
      const h = stick.height;
      const r = h / 2; // capsule radius

      // Capsule path (pill-shaped stick)
      ctx.beginPath();
      ctx.moveTo(-w/2 + r, -h/2);
      ctx.lineTo(w/2 - r, -h/2);
      ctx.arc(w/2 - r, 0, r, -Math.PI/2, Math.PI/2, false);
      ctx.lineTo(-w/2 + r, h/2);
      ctx.arc(-w/2 + r, 0, r, Math.PI/2, -Math.PI/2, false);
      ctx.closePath();

      // Fill wood gradient
      const wood = ctx.createLinearGradient(-w/2, 0, w/2, 0);
      wood.addColorStop(0, "#3b2f1a");
      wood.addColorStop(0.5, "#8c6239");
      wood.addColorStop(1, "#3b2f1a");
      ctx.fillStyle = wood;

      // Soft glow/shadow to pop from background
      ctx.shadowColor = "rgba(0,0,0,0.55)";
      ctx.shadowBlur = 10;
      ctx.fill();
      ctx.shadowBlur = 0;

      // Outline
      ctx.lineWidth = 2;
      ctx.strokeStyle = "#1c1108";
      ctx.stroke();

      // Wood grain (subtle, inside the capsule)
      ctx.save();
      ctx.clip();
      ctx.globalAlpha = 0.25;
      for (let x = -w/2 + 6; x < w/2; x += 14) {
        ctx.beginPath();
        ctx.moveTo(x, -h/2 + 2);
        ctx.lineTo(x + 6, h/2 - 2);
        ctx.strokeStyle = "#2c1f10";
        ctx.lineWidth = 1;
        ctx.stroke();
      }
      ctx.globalAlpha = 1;

      // Accent ring near the right cap so rotation is super obvious
      ctx.beginPath();
      ctx.lineWidth = 2;
      ctx.strokeStyle = "rgba(0,0,0,0.35)";
      ctx.arc(w/2 - r, 0, r * 0.6, -Math.PI/2, Math.PI/2);
      ctx.stroke();

      ctx.restore(); // end clip
      ctx.restore();
    }

    function draw() {
      ctx.clearRect(0, 0, canvas.width, canvas.height);

      // Slight background vignette
      const g = ctx.createRadialGradient(canvas.width/2, canvas.height/2, Math.min(canvas.width, canvas.height)*0.1,
                                         canvas.width/2, canvas.height/2, Math.max(canvas.width, canvas.height)*0.7);
      g.addColorStop(0, "#0f0f10");
      g.addColorStop(1, "#0a0a0b");
      ctx.fillStyle = g;
      ctx.fillRect(0, 0, canvas.width, canvas.height);

      drawStick();
      for (const r of rocks) drawRock(r);
    }

    function gameLoop() {
      update();
      draw();
      requestAnimationFrame(gameLoop);
    }

    // -------- Mouse control w/ proper torque --------
    // Add angular velocity based on the component of mouse velocity that is
    // perpendicular to the stick (physically feels like torque).
    canvas.addEventListener("mousemove", (e) => {
      const vx = e.clientX - lastMouseX;
      const vy = e.clientY - lastMouseY;

      // Stick normal (perpendicular) vector
      const nx = -Math.sin(stick.angle);
      const ny =  Math.cos(stick.angle);

      // Torque = velocity projected onto normal
      const torque = (vx * nx + vy * ny) * 0.01; // sensitivity
      stick.angularVelocity += torque;

      // Optional clamp so it doesn't go insane
      const maxSpin = 0.5;
      if (stick.angularVelocity > maxSpin) stick.angularVelocity = maxSpin;
      if (stick.angularVelocity < -maxSpin) stick.angularVelocity = -maxSpin;

      // Move stick to mouse
      stick.x = e.clientX;
      stick.y = e.clientY;

      lastMouseX = e.clientX;
      lastMouseY = e.clientY;
    });

    // Spawn rocks
    setInterval(spawnRock, 450);
    gameLoop();
  </script>
</body>
</html>
