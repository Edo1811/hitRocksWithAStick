<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Stick vs Rocks — Bounces & Boo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <style>
    :root { color-scheme: dark; }
    html, body {
      margin: 0;
      height: 100%;
      overflow: hidden;
      background: #0f0f10;
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Inter, Arial, sans-serif;
    }
    #score {
      position: fixed;
      top: 12px;
      left: 12px;
      padding: 6px 10px;
      background: rgba(0,0,0,0.35);
      border: 1px solid rgba(255,255,255,0.08);
      border-radius: 10px;
      font-weight: 700;
      letter-spacing: 0.5px;
      user-select: none;
    }
    canvas { display: block; }
  </style>
</head>
<body>
  <div id="score">Score: 0</div>
  <canvas id="gameCanvas"></canvas>

  <script>
    const canvas = document.getElementById("gameCanvas");
    const ctx = canvas.getContext("2d");

    function resize() {
      canvas.width = window.innerWidth;
      canvas.height = window.innerHeight;
    }
    window.addEventListener("resize", resize);
    resize();

    let score = 0;
    const scoreDisplay = document.getElementById("score");

    // ====== Audio (for "boooo") ======
    let audioCtx = null;
    function initAudio() {
      if (!audioCtx) {
        audioCtx = new (window.AudioContext || window.webkitAudioContext)();
      }
    }
    // Most browsers require a user gesture once to enable audio:
    document.addEventListener("pointerdown", () => {
      initAudio();
      audioCtx.resume();
    }, { once: true });

    function playBoo(intensity = 1) {
      if (!audioCtx) return;
      const now = audioCtx.currentTime;
      const dur = 0.22 + 0.12 * Math.min(intensity, 2);

      const osc = audioCtx.createOscillator();
      const filt = audioCtx.createBiquadFilter();
      const gain = audioCtx.createGain();

      osc.type = "sine";
      filt.type = "lowpass";
      filt.frequency.value = 700;
      filt.Q.value = 0.5;

      // Pitch glide down = "booo"
      osc.frequency.setValueAtTime(180, now);
      osc.frequency.exponentialRampToValueAtTime(90, now + dur);

      gain.gain.setValueAtTime(0.0001, now);
      gain.gain.exponentialRampToValueAtTime(0.45 * Math.min(1, intensity), now + 0.01);
      gain.gain.exponentialRampToValueAtTime(0.0001, now + dur);

      osc.connect(filt).connect(gain).connect(audioCtx.destination);
      osc.start(now);
      osc.stop(now + dur + 0.05);
    }

    // ====== BAT with handle pivot at the mouse ======
    const stick = {
      x: canvas.width / 2,   // pivot (handle) follows mouse
      y: canvas.height / 2,
      length: 170,           // bat length
      thickness: 22,         // bat thickness
      angle: 0,              // rotation around handle
      angularVelocity: 0
    };

    let lastMouseX = stick.x;
    let lastMouseY = stick.y;

    // ====== Rocks ======
    const rocks = [];
    const wallRestitution = 0.9;     // bouncy walls
    const batRestitution  = 1.05;    // juicy bat hits

    function spawnRock() {
      const r = {
        x: Math.random() * canvas.width,
        y: -40,
        radius: 22 + Math.random() * 18,
        vy: 2.2 + Math.random() * 2.2,
        vx: (Math.random() - 0.5) * 0.8,
        rotation: Math.random() * Math.PI * 2,
        rotationSpeed: (Math.random() - 0.5) * 0.03,
        shape: generateRockShape(16, 0.45)
      };
      rocks.push(r);
    }

    function generateRockShape(sides = 14, roughness = 0.35) {
      const pts = [];
      for (let i = 0; i < sides; i++) {
        const ang = (i / sides) * Math.PI * 2;
        const radJitter = 1 + (Math.random() * 2 - 1) * roughness;
        pts.push({ ang, radJitter });
      }
      return pts;
    }

    function drawRock(r) {
      ctx.save();
      ctx.translate(r.x, r.y);
      ctx.rotate(r.rotation);

      const R = r.radius;
      ctx.beginPath();
      const p0 = r.shape[0];
      ctx.moveTo(Math.cos(p0.ang) * R * p0.radJitter, Math.sin(p0.ang) * R * p0.radJitter);
      for (let i = 1; i < r.shape.length; i++) {
        const p = r.shape[i];
        ctx.lineTo(Math.cos(p.ang) * R * p.radJitter, Math.sin(p.ang) * R * p.radJitter);
      }
      ctx.closePath();

      const grad = ctx.createRadialGradient(-R * 0.2, -R * 0.25, R * 0.2, 0, 0, R);
      grad.addColorStop(0, "#a1a1a1");
      grad.addColorStop(1, "#555");
      ctx.fillStyle = grad;

      ctx.shadowColor = "rgba(0,0,0,0.6)";
      ctx.shadowBlur = 8;
      ctx.fill();

      ctx.shadowBlur = 0;
      ctx.lineWidth = 2;
      ctx.strokeStyle = "#2d2d2d";
      ctx.stroke();

      // subtle cracks
      ctx.globalAlpha = 0.35;
      ctx.beginPath();
      ctx.moveTo(-R * 0.2, -R * 0.1);
      ctx.lineTo(R * 0.35, R * 0.2);
      ctx.moveTo(-R * 0.3, R * 0.25);
      ctx.lineTo(R * 0.15, -R * 0.05);
      ctx.strokeStyle = "#2a2a2a";
      ctx.lineWidth = 1;
      ctx.stroke();
      ctx.globalAlpha = 1;

      ctx.restore();
    }

    // ====== Physics / Update ======
    function update() {
      // Angular motion (inertia)
      stick.angle += stick.angularVelocity;
      stick.angularVelocity *= 0.985; // friction

      for (let i = 0; i < rocks.length; i++) {
        const r = rocks[i];

        // Move
        r.x += r.vx;
        r.y += r.vy;
        r.rotation += r.rotationSpeed;

        // Screen-wall bounces
        if (r.x - r.radius < 0) {
          r.x = r.radius;
          r.vx = Math.abs(r.vx) * wallRestitution;
          r.rotationSpeed *= -1;
        } else if (r.x + r.radius > canvas.width) {
          r.x = canvas.width - r.radius;
          r.vx = -Math.abs(r.vx) * wallRestitution;
          r.rotationSpeed *= -1;
        }
        if (r.y - r.radius < 0) {
          r.y = r.radius;
          r.vy = Math.abs(r.vy) * wallRestitution;
          r.rotationSpeed *= -1;
        } else if (r.y + r.radius > canvas.height) {
          r.y = canvas.height - r.radius;
          r.vy = -Math.abs(r.vy) * wallRestitution;
          r.rotationSpeed *= -1;
        }

        // Mild air drag so things don't get infinite
        r.vx *= 0.999;
        r.vy *= 0.999;

        // Bat collision (bounce, not delete)
        const hit = circleVsBatWithContact(r.x, r.y, r.radius);
        if (hit) {
          // Score on each hit
          score++;
          scoreDisplay.textContent = `Score: ${score}`;

          // --- Compute bounce using relative velocity vs bat surface ---
          const n = hit.normal;                      // outward normal (world)
          const contact = hit.contactWorld;          // world point on bat
          const rx = contact.x - stick.x;            // vector from pivot to contact
          const ry = contact.y - stick.y;

          // Bat surface velocity at contact due to rotation (ω × r)
          const omega = stick.angularVelocity;       // rad per frame
          const vSurfX = -omega * ry;
          const vSurfY =  omega * rx;

          // Rock's current velocity
          const vRelX = r.vx - vSurfX;
          const vRelY = r.vy - vSurfY;

          // Reflect relative velocity across the normal
          const vn = vRelX * n.x + vRelY * n.y;      // normal component
          const vRefX = vRelX - (1 + batRestitution) * vn * n.x;
          const vRefY = vRelY - (1 + batRestitution) * vn * n.y;

          // New absolute velocity = surface velocity + reflected relative
          r.vx = vSurfX + vRefX;
          r.vy = vSurfY + vRefY;

          // Add a little tangential "grip" so hits feel spicy
          const tX = -n.y, tY = n.x;
          const vt = vRelX * tX + vRelY * tY;
          r.vx += tX * (0.05 * vt);
          r.vy += tY * (0.05 * vt);

          // Kick some spin into the rock
          r.rotationSpeed += (Math.random() * 0.6 - 0.3) + 0.2 * omega;

          // Nudge rock out of the bat so it doesn't stick
          r.x += n.x * (hit.penetration + 0.5);
          r.y += n.y * (hit.penetration + 0.5);

          // Play "boooo" based on impact strength
          const impact = Math.abs(vn) + Math.abs(omega) * Math.hypot(rx, ry);
          playBoo(Math.min(1 + impact * 0.05, 2));
        }
      }
    }

    // Circle vs oriented rectangle (bat), with contact info
    function circleVsBatWithContact(cx, cy, cr) {
      // Vector from pivot to circle center (world -> local)
      const rx = cx - stick.x;
      const ry = cy - stick.y;

      const c = Math.cos(stick.angle);
      const s = Math.sin(stick.angle);

      // world -> local (bat points along +local Y)
      const lx =  c * rx + s * ry;
      const ly = -s * rx + c * ry;

      const halfW = stick.thickness / 2;
      const minY = 0;
      const maxY = stick.length;

      // Closest point on the rectangle in local space
      const qx = Math.max(-halfW, Math.min(lx, halfW));
      const qy = Math.max(minY,  Math.min(ly, maxY));

      let dx = lx - qx;
      let dy = ly - qy;
      let dist2 = dx * dx + dy * dy;

      // If center is inside rect, pick normal of nearest face
      let nLocalX, nLocalY, penetration;
      if (dist2 === 0) {
        const distLeft   = (lx - (-halfW));
        const distRight  = (halfW - lx);
        const distBottom = (ly - minY);
        const distTop    = (maxY - ly);

        const minDist = Math.min(distLeft, distRight, distBottom, distTop);
        if (minDist === distLeft)      { nLocalX = -1; nLocalY =  0; penetration = cr; }
        else if (minDist === distRight){ nLocalX =  1; nLocalY =  0; penetration = cr; }
        else if (minDist === distBottom){nLocalX =  0; nLocalY = -1; penetration = cr; }
        else                           { nLocalX =  0; nLocalY =  1; penetration = cr; }
      } else {
        const dist = Math.sqrt(dist2);
        nLocalX = dx / dist;
        nLocalY = dy / dist;
        penetration = cr - dist;
        if (penetration < 0) return null;
      }

      // Local normal -> world
      const nx =  c * nLocalX - s * nLocalY;
      const ny =  s * nLocalX + c * nLocalY;

      // Contact point in world (transform q back)
      const qWorldX = stick.x + (c * qx - s * qy);
      const qWorldY = stick.y + (s * qx + c * qy);

      return {
        normal: { x: nx, y: ny },
        contactWorld: { x: qWorldX, y: qWorldY },
        penetration: Math.max(0, penetration)
      };
    }

    // ====== Render ======
    function drawStick() {
      ctx.save();
      ctx.translate(stick.x, stick.y);
      ctx.rotate(stick.angle);

      const L = stick.length;
      const T = stick.thickness;
      const r = T / 2;

      // Bat shape: rectangle 0..L-r + rounded tip
      ctx.beginPath();
      ctx.moveTo(-r, 0);
      ctx.lineTo(-r, L - r);
      ctx.arc(0, L - r, r, Math.PI, 0, false);
      ctx.lineTo(r, 0);
      ctx.closePath();

      // Wood gradient along length
      const wood = ctx.createLinearGradient(0, 0, 0, L);
      wood.addColorStop(0, "#3b2f1a");
      wood.addColorStop(0.5, "#8c6239");
      wood.addColorStop(1, "#3b2f1a");
      ctx.fillStyle = wood;

      ctx.shadowColor = "rgba(0,0,0,0.55)";
      ctx.shadowBlur = 10;
      ctx.fill();
      ctx.shadowBlur = 0;

      // Outline
      ctx.lineWidth = 2;
      ctx.strokeStyle = "#1c1108";
      ctx.stroke();

      // Grip band near handle
      ctx.save();
      ctx.beginPath();
      ctx.rect(-r, 0, T, Math.min(22, L * 0.15));
      ctx.clip();
      ctx.globalAlpha = 0.35;
      for (let y = 2; y < 22; y += 3) {
        ctx.beginPath();
        ctx.moveTo(-r, y);
        ctx.lineTo(r, y);
        ctx.strokeStyle = "#2c1f10";
        ctx.lineWidth = 1;
        ctx.stroke();
      }
      ctx.globalAlpha = 1;
      ctx.restore();

      // Subtle wood grain
      ctx.save();
      ctx.clip();
      ctx.globalAlpha = 0.2;
      for (let y = 6; y < L; y += 14) {
        ctx.beginPath();
        ctx.moveTo(-r + 4, y);
        ctx.lineTo(r - 4, y + 8);
        ctx.strokeStyle = "#2c1f10";
        ctx.lineWidth = 1;
        ctx.stroke();
      }
      ctx.globalAlpha = 1;
      ctx.restore();

      // Pivot marker (handle)
      ctx.beginPath();
      ctx.arc(0, 0, 3, 0, Math.PI * 2);
      ctx.fillStyle = "#ffd166";
      ctx.fill();
      ctx.lineWidth = 1;
      ctx.strokeStyle = "#d69e2e";
      ctx.stroke();

      ctx.restore();
    }

    function drawBackground() {
      const g = ctx.createRadialGradient(
        canvas.width / 2, canvas.height / 2, Math.min(canvas.width, canvas.height) * 0.1,
        canvas.width / 2, canvas.height / 2, Math.max(canvas.width, canvas.height) * 0.7
      );
      g.addColorStop(0, "#0f0f10");
      g.addColorStop(1, "#0a0a0b");
      ctx.fillStyle = g;
      ctx.fillRect(0, 0, canvas.width, canvas.height);
    }

    function draw() {
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      drawBackground();
      drawStick();
      for (const r of rocks) drawRock(r);
    }

    function gameLoop() {
      update();
      draw();
      requestAnimationFrame(gameLoop);
    }

    // ====== Mouse → pivot + torque around handle ======
    canvas.addEventListener("mousemove", (e) => {
      const vx = e.clientX - lastMouseX;
      const vy = e.clientY - lastMouseY;

      // Local X unit (perpendicular to bat's long axis which is +local Y)
      const exx = Math.cos(stick.angle);
      const exy = Math.sin(stick.angle);

      // Sideways motion adds spin
      const torque = (vx * exx + vy * exy) * 0.01;
      stick.angularVelocity += torque;

      // Clamp spin
      const maxSpin = 0.55;
      if (stick.angularVelocity > maxSpin) stick.angularVelocity = maxSpin;
      if (stick.angularVelocity < -maxSpin) stick.angularVelocity = -maxSpin;

      // Move pivot to mouse
      stick.x = e.clientX;
      stick.y = e.clientY;

      lastMouseX = e.clientX;
      lastMouseY = e.clientY;
    });

    // ====== Start ======
    setInterval(spawnRock, 500);
    gameLoop();
  </script>
</body>
</html>
